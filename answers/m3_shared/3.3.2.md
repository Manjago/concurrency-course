# Задание 3. Практика: гарантии при блокировках

Теперь разберём гарантии и ошибки этого кода:

```java
class Scratch {
    private Integer value = 0;
    private Lock lock = new ReentrantLock();

    public synchronized void add(Integer newValue) {
        this.value += newValue;
    }

    public Integer getValue() {
        try {
            lock.lock();
            log("Current value is " + value);
            return value;
        } finally {
            lock.unlock();
        }
    }
}
```

## Выберите подходящие варианты для следующих вопросов:

### 1. Какие гарантии даёт ```lock``` в методе ```getValue```?

#### Только один поток может зайти внутрь критической секции

Да, совершенно верно - это ```ReentrantLock```, он такие гарантии и даёт. 

#### Переменную ```value``` нельзя обновлять в этой критической секции

Таких требований нет - обновлять переменную ```value``` можно.

#### Переменная блокируется для обновления во всех методах класса

Нет, в других методах класса мы можем работать с этой переменной ```value``` напрямую, 
или через другие блоки синхронизации (но это вроде глупо)

#### Значение ```value``` не может быть null

Таких требований нет - значение ```value``` может быть null.

### 2. Какие гарантии даёт ```synchronized``` в методе ```add```?

#### Только один поток может зайти внутрь метода

Да, только один поток может зайти внутрь метода.

#### Значение ```newValue``` не может быть null

Нет, таких требований нет.

#### Переменная ```value``` блокируется для чтения в остальных методах класса

Нет, точно так же в других методах класса мы можем работать с этой переменной ```value``` напрямую,
или через другие блоки синхронизации (но это вроде глупо)

#### Ни один апдейт не потеряется

Если мы будем "смотреть" на переменную ```value``` из других методов, которые работают 
с этой переменной не в блоках синхронизации или в других блоках - то может и потеряться.

### 3. Какие проблемы возможны в этом коде?

#### Метод ```getValue``` прочитает устаревшее значение

Да, для модификации и для установки значнения разные блоки синхронизации с разными объектами 
синхронизации - может и прочитать устаревшее значение.

#### Метод ```getValue``` прочитает несуществующее значение

Нет, отсутствие несуществующих значений нам гарантирует JMM
#### ```СoncurrentModificationException```

Нет, такого исключения не будет - для этого исключения нет никаких оснований

### 4. Сколько потоков могут работать с переменной ```value``` одновременно? (работать = читать или обновлять)

Тут два разных блока синхронизации с двумя разными объектами 
синхронизации (```ReentrantLock``` и ```synchronized```) - соответственно, одновременно может работать
**два** потока
