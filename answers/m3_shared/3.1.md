# Задание 3. Практика: гонка между потоками

Перед вами код кэша, который оптимизирует работу с базой данных:

```java
class Scratch {

    public V read(K key) {                    /*  1*/
        V result = cache.getIfPresent(key);   /*  2*/
        if (result == null) {                 /*  3*/
            result = readFromDatabase(key);   /*  4*/
            cache.put(key, result);           /*  5*/
        }                                     /*  6*/
        return result;                        /*  7*/
    }                                         /*  8*/

    public void write(K key, V value) {       /*  9*/
        writeToDatabase(key, value);          /* 10 */
        cache.invalidate(key);                /* 11 */
    }                                         /* 12 */
}
```

Поток T1 хочет прочитать объект с ID=5, которого нет в кэше

Поток T2 в этот же момент обновляет в базе объект с ID=5

Предположим, что изменения в БД и кэше сразу видны другим потокам. 
Перечислите ситуации, которые отличаются от ожидаемого поведения и вызваны 
гонкой между потоками.

## Проблема 1: Потерянный update (modify-and-then) -  а конкретно, потерянное обновление кэша (изменилось значение в базе данных, но в кэш запихнули старье)

Пусть в кэше ничего нет.

Поток T1 проходит метод write key = KEY1, value = VALUE1
Поток T2 проходит строки 1, 2, 3, 4 с key = KEY1 (прочитал из базы значение VALUE1, но в кэш еще не положил)
Поток T3 проходит метод write key = KEY1б value = VALUE2
Поток T2 проходит стрроки 5, 6, 7, 8 (кладет в кэш старое значение VALUE1, возвращает его и теперь оно живет в кэше 
вечно, до инвалидации кэша)

## Проблема 2: Гонка (check-and-act) - напрасно дважды сходили в базу данных

Пусть в кэше ничего нет.

Поток T1 проходит строки 1, 2, 3, 4 и всит на строке 4(читает из базы данных значение VALUE_DB по key == key1)
Поток T2 проходит строки 1, 2 - в кэше ничего нет
Поток T1 проходит остаток метода до коцна (прочитал данные из базы, положил в кэш)
Поток T2 проходит остаток метода до коцна (прочитал данные из базы, положил в кэш).

Вроде большой беды нет, но (возможно?) неожиданное поведение и два раза читали из базы.


