# Часть 1: Spring Core

_Откройте класс SimpleAsyncTaskExecutor_

_Посмотрите, что происходит при вызове метода ```submit```_

_Задание:_

_1. Опишите, как в экзекьюторе в Spring задачи распределяются по потокам_

_2. Предположите, в каком случае имеет смысл переопределить экзекьютор по умолчанию_

Смотрим в самое начало, в javadoc - и уже там видим, что они честно написали

> NOTE: This implementation does not reuse threads! Consider a thread-pooling 
> TaskExecutor implementation instead, in particular for executing a large number 
> of short-lived tasks.

Соответственно, если следовать их подсказке, то в случае выполнения __большого количества
короткоживущих задач__ точно его использовать не надо, лучше использовать свой thread-pooling TaskExecutor

От себя, честно говоря, добавлю, что в своих проектах я этот SimpleAsyncTaskExecutor не 
использую (то есть, всегда пользуюсь @Async("свой-бин-с-экзекьтором"), а то и несколько - для
задач разных типов). C @Async без параметров есть вероятность, что спринг будет использовать как раз 
этот SimpleAsyncTaskExecutor, если ничего получше не найдет. Ни одного минуса от этого не вижу, кроме немного бОльшего количества писанины.

То есть мой практический ответ - __в любом реальном проекте на прод имеет смысл этот экзекьютор переопределить__

Использовать этот имеет смысл - ну разве что в каких-то совсем академических задачах.
Ну, например, я точно знаю, что ко мне 8 задач придет, которые надо будет сделать параллельно, после чего приложение 
завершит работу. Тогда, наверное, действительно не стоит париться с кастомным экзекьютором.

Или еще один вариант - этот экзекьтор может пригодиться для [предыдущей задачи](3.md) -  для случая sleep.
Прикрутим его, 
```java
private SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor();
```

и закомментарим ```shutdown```

```java
public void shutdown() {
  //  executor.shutdown();
}
```

Получаем

```
Execution time: 15028
```

Да, на уровне лучших результатов из отчета. 

Значит, для такой задачи со sleep тоже можно использовать (можно еще по вашему совету
ограничить максимальное количество тредов через the "concurrencyLimit"
bean property )